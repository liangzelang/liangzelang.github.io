<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>数据结构之树 | Zelang Liang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="树的相关概念树在数据结构中非常重要，应用也有很多。下面只记录一些重要的、基础性的概念。  结点：树由结点构成的，有根节点、叶结点等。结点有用的子树数就是结点的度，叶结点度为0.同一个父节点的结点互为兄弟，跟人一样，就不介绍，有点弱智的感觉。 树的深度： 树的根层次为1，根的子结点层次为2，依次类推。树中结点的最大层次即为树的深度或者高度。  树的存储结构和实现在上面概念中说了树中的结点关系和人一样">
<meta name="keywords" content="c++,数据结构与算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构之树">
<meta property="og:url" content="http://newbird.cn/2017/07/14/CPP/数据结构之树/index.html">
<meta property="og:site_name" content="Zelang Liang">
<meta property="og:description" content="树的相关概念树在数据结构中非常重要，应用也有很多。下面只记录一些重要的、基础性的概念。  结点：树由结点构成的，有根节点、叶结点等。结点有用的子树数就是结点的度，叶结点度为0.同一个父节点的结点互为兄弟，跟人一样，就不介绍，有点弱智的感觉。 树的深度： 树的根层次为1，根的子结点层次为2，依次类推。树中结点的最大层次即为树的深度或者高度。  树的存储结构和实现在上面概念中说了树中的结点关系和人一样">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-09-30T09:34:19.065Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构之树">
<meta name="twitter:description" content="树的相关概念树在数据结构中非常重要，应用也有很多。下面只记录一些重要的、基础性的概念。  结点：树由结点构成的，有根节点、叶结点等。结点有用的子树数就是结点的度，叶结点度为0.同一个父节点的结点互为兄弟，跟人一样，就不介绍，有点弱智的感觉。 树的深度： 树的根层次为1，根的子结点层次为2，依次类推。树中结点的最大层次即为树的深度或者高度。  树的存储结构和实现在上面概念中说了树中的结点关系和人一样">
  
    <link rel="alternate" href="/atom.xml" title="Zelang Liang" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zelang Liang</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">New Bird , New Beginning</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">主页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">个人</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://newbird.cn"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-CPP/数据结构之树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/14/CPP/数据结构之树/" class="article-date">
  <time datetime="2017-07-14T02:53:48.000Z" itemprop="datePublished">2017-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/技术/">技术</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据结构之树
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="树的相关概念"><a href="#树的相关概念" class="headerlink" title="树的相关概念"></a>树的相关概念</h2><p>树在数据结构中非常重要，应用也有很多。下面只记录一些重要的、基础性的概念。</p>
<ul>
<li>结点：树由结点构成的，有根节点、叶结点等。结点有用的子树数就是结点的度，叶结点度为0.同一个父节点的结点互为兄弟，跟人一样，就不介绍，有点弱智的感觉。</li>
<li>树的深度： 树的根层次为1，根的子结点层次为2，依次类推。树中结点的最大层次即为树的深度或者高度。</li>
</ul>
<h2 id="树的存储结构和实现"><a href="#树的存储结构和实现" class="headerlink" title="树的存储结构和实现"></a>树的存储结构和实现</h2><p>在上面概念中说了树中的结点关系和人一样，树的存储就是把这些结点关系存起来。根据人的经验，从不同角度介绍某个人的方式是不一样的，介绍你亲姐：这是我姐，这是我父母的女儿……数的存储和实现也一样。</p>
<ol>
<li>双亲表示法   <strong>|data|parent|</strong><a id="more"></a>
data存储数据，parent指向结点的父节点在存储数组中的下标<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_TREE_SIZE 100</span><br><span class="line">typedef struct PTNode&#123;</span><br><span class="line">	int data;</span><br><span class="line">	int parent;</span><br><span class="line">&#125; PTNode;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">	int r, n;  //分别保存根节点的位置和结点数</span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上只是一个最简单最基本的实现，完全可以根据自己的要求更改，比如可以在PTNode中加入堂兄结点的位置等等。</p>
<ol start="2">
<li>孩子表示法 </li>
</ol>
<ul>
<li>|data|child1|child2|……<br>每个结点存储自己结点的数据，以及其子结点的指针，构成多重链表。</li>
<li>|data|degree|child1|child2|……|childd|<br>上面那个结构会浪费较多的空间，所有建立一个degree，但是问题是每个结点的结构不一样，运算会很麻烦，又产生下面的结构：</li>
<li>分为两种结点结构，一个是孩子结点链表，一种是表头结点 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_TREE_SIZE 100</span><br><span class="line">typedef struct CTNode  //孩子结点</span><br><span class="line">&#123;</span><br><span class="line">	int child;</span><br><span class="line">	struct CTNode * next;  //指向下一个孩子结点</span><br><span class="line">&#125; *ChildPtr；</span><br><span class="line">typedef struct  //表头结点</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	ChildPtr firstchild;  //指向第一个孩子结点</span><br><span class="line">&#125; CTBox;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	CTBox nodes[MAX_TREE_SIZE];   //结点数组</span><br><span class="line">	int r, n;  //根的位置和结点数</span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面的这个结构还是有不足的，比如我有一个结点，我怎么知道这个结点的父节点呢，所以可以在上面那个表头结点中加一个父节点的信息，这个不贴代码了。</p>
<ol start="3">
<li>孩子兄弟表示法 |data|firstchild|righsib|<br>这个结构就是结点的第一个子结点和一个右兄弟……实现如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct CSNode</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct CSNode * firstchild;</span><br><span class="line">	struct CSNode * rightsib;</span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果认真观察上面的结构，就会发现变成一个二叉树结构……二叉树可是树中最最重要的……<br>综上，几种树表示方法和实现就搞定了。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>正常智商都能理解到二叉树就是有最多两个叉(分支)的树，这个结构简单、极具特点，很有意义。</p>
<p><strong>二叉树特点：</strong></p>
<ul>
<li>每个结点最多两个子树</li>
<li>左子树和右子树是有顺序的</li>
<li>如果结点只有一个子树，也是要区分左右子树的(这个区分二叉树的形态)<br>因为二叉树的特点，产生了很多特殊二叉树</li>
</ul>
<ol>
<li>斜树：所有结点只有左结点或者右结点，分别叫左右斜树</li>
<li>满二叉树：所有分支结点都有左右子结点，而且叶结点都在同一层</li>
<li>完全二叉树：除了最下面一层，都是满的，而且最下面左面连续（满二叉树就是一种特殊的完全二叉树）</li>
</ol>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ol>
<li>在第i层最多有2^(i-1)个结点</li>
<li>深度为k的二叉树最多有2^k-1个结点</li>
<li>对于任意一个二叉树，叶结点为n0，度为2的结点数(就是有两个子结点)为n1,则有n0 = n1+1</li>
<li>具有n个结点的完全二叉树，深度[logn]+1,其中[logn]表示不大于logn的最大整数</li>
<li>一棵n结点的完全二叉树，结点按层序编号，对于结点i，<br>++ i=1，则结点i为根，无父结点；如果i&gt;1,则父结点是[i/2]<br>++ 2i&gt;n,则结点i不存在左孩子(是叶结点)，否则其左孩子为结点2i<br>++ 2i+1&gt;n, 则结点i无右孩子，否则右孩子为结点2i+1</li>
</ol>
<h2 id="二叉树的存储与实现"><a href="#二叉树的存储与实现" class="headerlink" title="二叉树的存储与实现"></a>二叉树的存储与实现</h2><p>之前有说过树的存储和实现，有很多方法，二叉树也可以使用之前的那些方法。不过由于二叉树比较特别，所以有更加方便简单的实现。</p>
<ol>
<li>顺序存储结构</li>
</ol>
<ul>
<li>如果是完全二叉树，按照层次依次对结点编号，那么直接按照标号依次顺序存储即可，很简单.</li>
<li>当然如果不是完全二叉树，也按照完全二叉树编号，在不存在的结点设置为’null’什么的都行，然后依次顺序存储。这样一棵斜树就会出现极度浪费空间的情况，这也是顺序存储的一个局限。</li>
</ul>
<ol start="2">
<li>二叉链表<br>上面谈到顺序存储的局限，我们就是用链表来实现二叉树，结构很简单<strong>|lchild|data|rchild|</strong>。data存储结点数据，两边分布存储其左右孩子结点指针。结构定义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct BiNode</span><br><span class="line">&#123;</span><br><span class="line">	int data;</span><br><span class="line">	struct BiNode * lchild;</span><br><span class="line">	struct BiNode * rchild;</span><br><span class="line">&#125; BiNode, * BiTree;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上就可以很好完成二叉树的实现，如果要添加结点或者删除结点都非常简单，也可以增加指向父结点的指针……都可以，根据自己的需求改一改就OK了。</p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a><strong>二叉树的遍历</strong></h2><p>如果一棵树中，需要找寻需要的内容，那么久需要二叉树的遍历。遍历是非常重要的内容。<br><strong>定义：</strong>  <em>从根节点出发，按照某种次序访问所有二叉树结点，使每个结点被访问有且仅有一次。</em></p>
<h3 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a><strong>二叉树遍历方法</strong></h3><h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>如果二叉树为空，返回空；否则先访问根节点，再前序遍历左子树，再前序遍历右子树(很明显这是一个递归过程)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PreOrder(BiTree T)  //BiTree 结构在前面阐述过</span><br><span class="line">&#123;</span><br><span class="line">	if(T == NULL)</span><br><span class="line">		return;</span><br><span class="line">	printf(&quot;%c&quot;,T-&gt;data);</span><br><span class="line">	PreOrder(T-&gt;lchild);</span><br><span class="line">	PreOrder(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>如果二叉树为空，返回空；否则从根节点开始（不是访问根节点），中序遍历根结点的左子树，然后访问根节点，最后中序遍历根结点的右子树。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void InOrder(BiTree T)  </span><br><span class="line">&#123;</span><br><span class="line">	if(T == NULL)</span><br><span class="line">		return;</span><br><span class="line">	InOrder(T-&gt;lchild);</span><br><span class="line">	printf(&quot;%c&quot;,T-&gt;data);</span><br><span class="line">	InOrder(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>如果二叉树为空，返回空；否则从左到右、先叶结点再父结点遍历访问左右子树，在访问根节点。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void PostOrder(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">	if(T == NULL)</span><br><span class="line">		return;</span><br><span class="line">		PostOrder(T-&gt;lchild);</span><br><span class="line">		PostOrder(T-&gt;rchild);</span><br><span class="line">		printf(&quot;%c&quot;,T-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>如果二叉树为空，返回空；否则从树的第一层开始，从上到下逐层遍历，同一层，从左到右顺序访问。<br>由于之前的树结构不太适合这个，所以就没有实现代码了，了解就行啦。</p>
<h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><p>前面说了二叉树的存储和实现，以及遍历方式。但是怎么利用相应的结构建立一棵二叉树呢？<br>使用前序遍历的方式进行递归创建，空树就用‘#’<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void createBiTree(BiTree * T)</span><br><span class="line">&#123;</span><br><span class="line">	int ch;</span><br><span class="line">	scanf(&quot;%c&quot;,&amp;ch);</span><br><span class="line">	if(ch == &apos;#&apos;)</span><br><span class="line">		*T = NULL;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		*T = (BiTree)malloc(sizeof(BiNode));</span><br><span class="line">		if(!*T)</span><br><span class="line">			return;</span><br><span class="line">		(*T)-&gt;data = ch;</span><br><span class="line">		createBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">		createBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二叉树的线索化"><a href="#二叉树的线索化" class="headerlink" title="二叉树的线索化"></a>二叉树的线索化</h2><p>当我们建立好二叉树后，我们会发现一些查找和搜索工作都不方便，而且建立的二叉树很多空间其实都是没有利用，所以我们把这些‘#’空间换成这些结点的前驱或者后继。</p>
<p>树其实还有很多内容，但是我水平有限，只能分享一些基础的知识。有时间会继续分享关于树的其他知识点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://newbird.cn/2017/07/14/CPP/数据结构之树/" data-id="ckhkaueo00006cbplrrb0p0hn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/08/19/CPP/数据结构之链表-队列-串/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数据结构之链表-队列-串
        
      </div>
    </a>
  
  
    <a href="/2017/07/04/CPP/排序算法总结/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">排序算法总结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    <% if (site.tags.length){ %>
  <div class="widget-wrap">
    <h2 class="widget-title"><b>关于我</b></h2>
    <div class="widget">
 <front size="3"><b>邮箱</b>：liangzelang@gmail.com<br>
 <b>现状</b>： 目前北京理工大学模式识别硕士在读，2018年毕业。个人喜欢图像处理、计算机视觉、机器学习等领域。我的<a href="http://oapeb119y.bkt.clouddn.com/%E9%99%84%E4%BB%B6%E4%BA%8C%EF%BC%9A%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86.pdf">个人简历</a></front>
    </div>
  </div>
<% } %>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">37</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/生活/">生活</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Caffe/">Caffe</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/">OpenCV</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV基础/">OpenCV基础</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ResNet/">ResNet</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TLD/">TLD</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VS2010/">VS2010</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leetcode/">leetcode</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/图像处理/">图像处理</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/多线程/">多线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/目标跟踪/">目标跟踪</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Caffe/" style="font-size: 10px;">Caffe</a> <a href="/tags/Linux/" style="font-size: 11.43px;">Linux</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/OpenCV/" style="font-size: 12.86px;">OpenCV</a> <a href="/tags/OpenCV基础/" style="font-size: 15.71px;">OpenCV基础</a> <a href="/tags/ResNet/" style="font-size: 10px;">ResNet</a> <a href="/tags/TLD/" style="font-size: 10px;">TLD</a> <a href="/tags/VS2010/" style="font-size: 10px;">VS2010</a> <a href="/tags/c/" style="font-size: 20px;">c++</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/leetcode/" style="font-size: 17.14px;">leetcode</a> <a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a> <a href="/tags/图像处理/" style="font-size: 14.29px;">图像处理</a> <a href="/tags/多线程/" style="font-size: 10px;">多线程</a> <a href="/tags/数据结构与算法/" style="font-size: 18.57px;">数据结构与算法</a> <a href="/tags/深度学习/" style="font-size: 10px;">深度学习</a> <a href="/tags/目标跟踪/" style="font-size: 12.86px;">目标跟踪</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/11/CPP/C++并发编程学习总结1/">C++多线程编程指南</a>
          </li>
        
          <li>
            <a href="/2020/11/11/Summary/hexo+github博客使用指南/">hexo使用指南</a>
          </li>
        
          <li>
            <a href="/2020/09/30/Linux_shell/正则表达式/">正则表达式</a>
          </li>
        
          <li>
            <a href="/2020/08/02/Leetcode/5-最长回文子串-C-中心扩展-暴力-md/">[5. 最长回文子串] C + 中心扩展 + 暴力</a>
          </li>
        
          <li>
            <a href="/2017/08/24/CPP/数据结构之图论基础/">数据结构之图论基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 liangzelang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
	<p>Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></p>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">个人</a>
  
</nav>
    

<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>